说明KMP算法看懂了觉得特别简单，思路很简单，看不懂之前，查各种资料，看的稀里糊涂，即使网上最简单的解释，依然看的稀里糊涂。我花了半天时间，争取用最短的篇幅大致搞明白这玩意到底是啥。这里不扯概念，只讲算法过程和代码理解：KMP算法求解什么类型问题字符串匹配。给你两个字符串，寻找其中一个字符串是否包含另一个字符串，如果包含，返回包含的起始位置。如下面两个字符串：比如我们已经知道ababab，q=4时，next[4]=2（k=2，表示该字符串的前5个字母组成的子串ababa存在相同的最长前缀和最长后缀的长度是3，所以k=2,next[4]=2。这个结果可以理解成我们自己观察算的，也可以理解成程序自己算的，这不是重点，重点是程序根据目前的结果怎么算next[5]的）.，那么对于字符串ababab，我们计算next[5]的时候，此时q=5, k=2（上一步循环结束后的结果）。那么我们需要比较的是str[k+1]和str[q]是否相等，其实就是str[1]和str[5]是否相等！，为啥从k+1比较呢，因为上一次循环中，我们已经保证了str[k]和str[q]（注意这个q是上次循环的q）是相等的（这句话自己想想，很容易理解），所以到本次循环，我们直接比较str[k+1]和str[q]是否相等（这个q是本次循环的q）。如果相等，那么跳出while()，进入if()，k=k+1，接着next[q]=k。即对于ababab，我们会得出next[5]=3。 这是程序自己算的，和我们观察的是一样的。如果不等，我们可以用”ababac“描述这种情况。 不等，进入while()里面，进行k=next[k]，这句话是说，在str[k + 1] != str[q]的情况下，我们往前找一个k，使str[k + 1]==str[q]，是往前一个一个找呢，还是有更快的找法呢？（一个一个找必然可以，即你把 k = next[k] 换成k- -也是完全能运行的（更正：这句话不对啊，把k=next[k]换成k–是不行的，评论25楼举了个反例）。但是程序给出了一种更快的找法，那就是 k = next[k]。 程序的意思是说，一旦str[k + 1] != str[q]，即在后缀里面找不到时，我是可以直接跳过中间一段，跑到前缀里面找，next[k]就是相同的最长前缀和最长后缀的长度。所以，k=next[k]就变成，k=next[2]，即k=0。此时再比较str[0+1]和str[5]是否相等，不等，则k=next[0]=-1。跳出循环。
（这个解释能懂不？）我们可以看到，匹配串每次往前移动，都是一大段一大段移动，假设匹配串里不存在重复的前缀和后缀，即next的值都是-1，那么每次移动其实就是一整个匹配串往前移动m个距离。然后重新一一比较，这样就比较m次，概括为，移动m距离，比较m次，移到末尾，就是比较n次，O(n)复杂度。 假设匹配串里存在重复的前缀和后缀，我们移动的距离相对小了点，但是比较的次数也小了，整体代价也是O(n)。所以复杂度是一个线性的复杂度。